name: Cedar Policy Validation

# This workflow runs the same validation logic as local scripts:
# - Local development: ./scripts/quick-validate.sh
# - Pre-commit testing: ./scripts/run-all-tests.sh  
# - GitHub Actions simulation: ./scripts/mock-gha.sh
# See docs/local-testing.md for local development workflow

on:
  pull_request:
    branches: [main]
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'LICENSE'

# Set the permissions at the workflow level
permissions:
  id-token: write  # Required for OIDC
  contents: read
  pull-requests: write

env:
  AWS_REGION: us-east-1
  STACK_NAME: cedar-policy-store-${{ github.repository_owner }}-${{ github.event.repository.name }}
  REPO_NAME: ${{ github.repository }}

jobs:
  validate:
    name: Validate Policies
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust and Cargo
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Cargo Registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-

      - name: Cache Cedar CLI Binary
        id: cache-cedar
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cedar
          key: ${{ runner.os }}-cedar-cli-4.4.1

      - name: Install Cedar CLI
        if: steps.cache-cedar.outputs.cache-hit != 'true'
        uses: taiki-e/install-action@v2
        with:
          tool: cedar-policy-cli@4.4.1

      - name: Verify Cedar Installation
        run: cedar --version

      - name: Make scripts executable
        run: chmod +x ./scripts/*.sh
          
      - name: Run Cedar Tests
        run: |
          echo "Running Cedar test suite (same as ./scripts/cedar_testrunner.sh locally)..."
          ./scripts/cedar_testrunner.sh

  deploy:
    name: Deploy to Production
    needs: validate
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.GHA_OIDC_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: cedar-deploy-${{ github.run_id }}
          role-duration-seconds: 3600

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Extract repository owner and name
        id: repo
        run: |
          OWNER=${GITHUB_REPOSITORY%/*}
          REPO=${GITHUB_REPOSITORY#*/}
          echo "owner=$OWNER" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT

      - name: Deploy CloudFormation Stack
        run: |
          echo "Deploying CloudFormation stack..."
          aws cloudformation deploy \
            --template-file cf/avp-stack.yaml \
            --stack-name ${{ env.STACK_NAME }} \
            --parameter-overrides \
                GitHubOrg=${{ steps.repo.outputs.owner }} \
                GitHubRepo=${{ steps.repo.outputs.repo }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset

      - name: Get Stack Outputs
        id: stack-outputs
        run: |
          echo "policy_store_id=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`PolicyStoreId`].OutputValue' \
            --output text)" >> $GITHUB_OUTPUT

      - name: Upload Cedar Policies to AVP
        env:
          POLICY_STORE_ID: ${{ steps.stack-outputs.outputs.policy_store_id }}
        run: |
          echo "Starting policy upload..."
          
          # Upload all Cedar policies
          for policy_file in policies/*.cedar; do
            if [ -f "$policy_file" ]; then
              policy_name=$(basename "$policy_file" .cedar)
              echo "Uploading policy: $policy_name"
              
              # Create policy definition
              policy_statement=$(cat "$policy_file")
              policy_json=$(jq -n --arg stmt "$policy_statement" \
                '{static: {description: "Deployed via GitHub Actions", statement: $stmt}}')
              
              # Try to create or update the policy
              if aws verifiedpermissions create-policy \
                --policy-store-id "$POLICY_STORE_ID" \
                --definition "$policy_json" \
                --region ${{ env.AWS_REGION }} 2>/dev/null; then
                echo "Created policy: $policy_name"
              else
                echo "Policy may already exist, attempting update..."
                # Note: Update requires policy ID, which we'd need to fetch
                echo "Skipping update for now"
              fi
            fi
          done
          
      - name: Test S3 Bucket Compliance
        env:
          POLICY_STORE_ID: ${{ steps.stack-outputs.outputs.policy_store_id }}
        run: |
          echo "Testing S3 bucket compliance with Cedar policies..."
          
          # Make compliance check script executable
          chmod +x ./scripts/check-s3-bucket-compliance.sh
          
          # Test against any existing S3 buckets in the account
          echo "Checking S3 buckets for encryption compliance..."
          
          # Get list of buckets and test compliance (this will work with any buckets)
          for bucket in $(aws s3api list-buckets --query 'Buckets[].Name' --output text 2>/dev/null | head -3); do
            echo "Testing bucket: $bucket"
            ./scripts/check-s3-bucket-compliance.sh "$bucket" || echo "Bucket $bucket failed compliance check"
          done
          
          echo "S3 compliance testing completed"
